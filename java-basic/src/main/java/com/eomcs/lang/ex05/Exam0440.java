package com.eomcs.lang.ex05;

//# 비트 연산자 : 응용 I
//
public class Exam0440 {
  public static void main(String[] args) {

    // i 변수에 들어있는 값을 순서대로 1바이트씩 잘라서
    // a,b,c,d 변수에 넣은 다음 각 변수의 값을 16진수로 출력하라!
    int i = 0x27a130ff; // (16진수)
    int a, b, c, d;

    System.out.println(i);
    System.out.println(Integer.toHexString(i));


    // [00100111_10100001_00110000_11111111] => 27a130ff // 원본값

    a = i >> 24;
    // [00000000_00000000_00000000_00100111]_10100001_00110000_11111111

    b = i >> 16 & 0xff;
    //  [00100111_10100001_00110000_11111111] => 27a130ff
    //  [00000000_00000000_00100111_10100001]_00110000_11111111 // 1) 일단 16비트 버림
    //   00000000_00000000_00100111_10100001  => 0x000027a1 // 2) 내가 원하는 숫자 추출하기
    // & 00000000_00000000_00000000_11111111  => 0x000000ff // 3 어떤 값에 & 연산자를 쓰면 해당 값을 그대로 통과시키는 필터 효과 발생
    // --------------------------------------                 // 둘 다 1일 때만 통과가 가능해서 & 연산자를 0이랑 쓰면 0이 된다
    //   00000000_00000000_00000000_10100001

    c = i >> 8 & 0xff;
    //  [00100111_10100001_00110000_11111111] => 27a130ff
    //  [00000000_00100111_10100001_00110000]_11111111
    //   00000000_00100111_10100001_00110000  => 0x0027a130
    // & 00000000_00000000_00000000_11111111  => 0x000000ff  // 앞은 전부 0이고 끝에만 ff 값 사용 (내가 원하는 값이 마지막에 있으니까)
    // --------------------------------------
    //   00000000_00000000_00000000_00110000

    d = i & 0xff;
    //  [00100111_10100001_00110000_11111111] => 27a130ff
    //  [00100111_10100001_00110000_11111111]
    //   00100111_10100001_00110000_11111111  => 0x27a130ff
    // & 00000000_00000000_00000000_11111111  => 0x000000ff
    // --------------------------------------
    //   00000000_00000000_00000000_11111111

    System.out.println(Integer.toHexString(a)); // a값을 그냥 출력하면 10진수로 출력되기 때문에 toHex 사용하여 16진수 문자로 출력
    System.out.println(Integer.toHexString(b)); // 오리지날 값을 1바이트로 끊어서 출력
    System.out.println(Integer.toHexString(c));
    System.out.println(Integer.toHexString(d));


  }
}
