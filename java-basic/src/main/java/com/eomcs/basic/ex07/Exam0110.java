// java.util.HashSet 클래스 사용 - 중복저장 불가 테스트
package com.eomcs.basic.ex07;

import java.util.HashSet;

// *** HashSet의 특징 => 중복 여부: hashCode()의 리턴 값과 equals()가 true일 때는 같은 값!
//
// 1) 값을 중복 저장하지 않는다.
//    - Set은 집합을 의미한다.
//    - 집합에서는 중복값을 허용하지 않는다.
//    - 값의 중복 여부는 hashCode()의 리턴 값이 같고,
//      equals()의 검사 결과가 true일 때
//      같은 값으로 취급한다.
//    - 즉 중복된 값을 저장하고 싶지 않을 때 HashSet을 사용한다.
// 2) 값을 순서대로 저장하지 않는다.
//    - 값 객체의 hashCode()의 리턴 값으로 저장 위치를 계산하기 때문에
//      add() 한 순서대로 저장되지 않는다.
//    - 그래서 값을 index를 이용하여 꺼낼 수 없다.
//
public class Exam0110 {
  public static void main(String[] args) {
    HashSet<String> set = new HashSet<>();

    // new String()으로 만들면 서로 다른 인스턴스이다.
    // 헷갈릴까 봐 new String() 추가해 줌

    // Set에 값 추가하기
    set.add(new String("aaa"));
    set.add(new String("bbb"));
    set.add(new String("ccc"));

    // Set은 집합의 특성을 따른다.
    // 같은 값을 중복해서 넣을 수 없다.
    set.add(new String("aaa")); // 위에서 입력한 "aaa"와 인스턴스가 달라도 중복된 것으로 간주.
    set.add(new String("bbb")); // 위에서 입력한 "bbb"와 인스턴스가 달라도 중복된 것으로 간주.

    // null을 넣을 수 있다. 단 중복해서 넣을 수 없다.
    set.add(null);
    set.add(null);

    System.out.println(set);
    // 출력 결과를 보면 입력 순서와 다르다.
    // 이유?
    // - 저장할 때 각 인스턴스의 hashCode() 리턴 값으로 위치를 정하기 때문이다.
  }
}

// ** List와 Set ** (그림 참조)
//
//    >> 하단은 아래에서 위를 상속 받음
// Iterable(인터페이스) 핵심: iterator(), forEach() 정의하고 있음
// Collection(인터페이스): add(), remove(), size(), isEmpty()(지금 상황이 비어있는지 아닌지),
//                          contains()(해당 내용을 포함하는지 아닌지), clear(), toArray()(목록 리턴)
//
//    >> 하단은 Collection 을 상속 받음
//    >> Set은 집합이기 때문에 Index와 관련된 게 없어서 List와 헷갈리면 안 됨!!
//    >>      => 집합은 인덱스와 관련된 메서드가 없다.
//    >>      => 목록에 값을 입력한 순서를 관리하지 않는다.
//    >>      => 순서에 따라 관리하고 싶다면 Set을 사용하면 안 된다!
// List(인터페이스): get(), set(), indexOf() << List의 가장 큰 핵심
//                   => List는 인덱스로 값을 다루는 메서드가 있다.
//                   => 왜? 인덱스로 값을 저장하기 때문
// Set(인터페이스): copyOf()(집합을 copy) + Collection을 그대로 구현함
//                  => Set은 인덱스로 값을 다루지 않는다
//                  => 순서대로 저장하지 않는다.
//
//  ** Set **
// Set이란 규칙에 따라 목록을 관리하고 싶다면 ** HashSet **을 사용해라!
//
//  ** HashSet ** (ex. 경험했다~ 얼마 전에~ --> 백신 예약 10부제, 주민번호 뒷자리)
//     >> 일종의 hashSet은 내부적으로 값을 저장할 때
//     >> hash 값을 가지고 방 배정을 한다.
//
// ex. 0) 숫자가 0 ~ 7까지 있다고 가정한다면
//     1) "aaa" 라는 문자열을 add() 시켰을 때
//     2) hashCode() 를 리턴받는다 (해시값)
//     3) 만약 해시값이 27이 나왔다면 27에 대해 8로 나누면 나머지가 3이다
//     4) 그러면 해시값을 가지고 저장할 방의 위치를 결정하게 되는데,
//     5) 나머지로 나온 3에 문자열 "aaa"를 저장하게 된다.
//
//     1) 만약 문자열 "bbb"가 있고, hashCode() 리턴값이 21이면,
//     2) 21 / 8 = 5(나머지) 이기 때문에,
//     3) 나머지로 나온 5에 문자열 "bbb"를 저장한다.
//
//     1) 만약 문자열 "bba"가 있고, hashCode() 리턴값이 5라면,
//     2) 5 / 8 = 5(나머지) 이기 때문에,
//     3) 나머지로 나온 5에 문자열 "bba"를 저장한다.
//
//     1) 만약 문자열 "ccc"가 있고, hashCode() 리턴값이 32라면,
//     2) 32 / 8 = 0(나머지) 이기 때문에,
//     3) 나머지로 나온 0에 문자열 "ccc"를 저장한다.
//
//     1) 만약 문자열 "ddd"가 있고, hashCode() 리턴값이 64라면,
//     2) 64 / 8 = 0(나머지) 이기 때문에,
//     3) 나머지로 나온 0에 문자열 "ddd"를 저장한다.
//
//     1) 만약 문자열 "eee"가 있고, hashCode() 리턴값이 16라면,
//     2) 16 / 8 = 0(나머지) 이기 때문에,
//     3) 나머지로 나온 0에 문자열 "eee"를 저장한다.
//
//     1) 만약 문자열 "xxx"가 있고, hashCode() 리턴값이 16라면,
//     2) 16 / 8 = 0(나머지) 이기 때문에,
//     3) 나머지로 나온 0에 문자열 "xxx"를 저장해야 하는데,
//     4) 위에서 나온 값에 따라 이미 0에 16 / 8 = 0의 값을 가진 "eee"가 있다면,
//     5) equals()로 값을 검사한다.
//     6) 집합의 특성이 서로 다르기 때문에 "xxx"도 0에 저장된다.
//
//     1) 또 다른 27 / 8 = 3이라는 값을 가진 "aaa"를 저장하려고 하는데,
//     2) 이미 3의 자리에는 hashCode()와 equals()의 결과 값이 같은 객체가 있기 때문에
//     3) 중복으로 저장하지 않는다.
//
// ** ArrayList ** (그림 참고)
// - 한 줄에 매단다
// - 매다는 위치 정보 => 인덱스 사용
//
// ** HashSet ** (그림 참고, https://visualgo.net/en/hashtable 참고)
// - 여러 줄에 매단다
// - 매다는 위치 정보 => 해시값 사용




















