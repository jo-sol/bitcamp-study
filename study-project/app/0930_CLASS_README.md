# 19-g. 다중 클라이언트 접속 처리

   # 클라이언트 > 요청자
   # 서버 > 요청을 (들어 주는) 응답해 주는 자

# 네트워킹

  ㄴ *) Connection-Oriented = TCP // ==> ex. 전화
      ㄴ 연결 후 데이터 송/수신
      ㄴ 데이터 송/수신에 대한 신뢰 보장
          ㄴ Stateful    -----   연결 > 요청 > 응답 ( > 요청 ) > 끊기
          ㄴ Stateless   -----   연결 > 요청 > 응답 > 끊기

  ㄴ *) Connectionless = UDP // ==> ex. 편지, 택배, 라디오
      ㄴ 연결 없이 데이터 송/수신


(1) Stateful

  [고객] <-----------> [상담사]
          1. 연결
          2. 문의 <-> 답변
          3. 답변 <-> 문의
          4. 끊기
      
  * 클라이언트가 연결을 끊기 전까지 계속 연결되어 있다.
     ex) 게임 > 캐릭터를 생성하면 서버는 해당 캐릭터를 계속 유지해야 함
     ex) 채팅 > 대화가 남아있음
  ----------------------------------
    1) 소수의 클라이언트 요청 처리
    2) 연결되어 있는 동안 서버는 클라이언트 정보를 유지
       --> ex. 상담원은 서버가 끊어질 때까지 내가 누구인지 계속 알고 있을 수 있음
    3) 메모리 많이 사용
    4) ex. 한 사람의 연결이 완전히 끊어질 때까지 나머지 사람들은 대기해야 함(= Queue)
    // 단점!! 현재 연결 중인 클라이언트가 연결을 끊을 때까지 다음 클라이언트는 계속 대기하고 있어야 한다.
    //  => 해결 방안!! 한 번 요청하고 그 다음 요청을 끊어 버림으로써 시간과 속도를 줄일 수 있다. (= Stateless)

(2) Stateless

  [고객] <-----------> [상담사] (ex. 코로나 인증 전화 / 114 전화 안내)
          1. 연결
          2. 인증요청
          3. 답변
          4. 끊기
      
  * 응답 후 즉시 연결을 끊는다.
    ex) 검색 > 키워드를 한 번 던지면 끝남
    ex) 메일 > 한 번 보내고 응답받으면 끝
  ----------------------------------- 
    1) 다수의 클라이언트 요청 처리
    2) 서버는 클라이언트 정보를 유지하지 않는다.
       --> ex. 114에 걸었을 때 정보를 받고 전화를 끊는 순간 서버에서 모든 정보가 사라짐
    3) 메모리 적게 사용
    4) 














